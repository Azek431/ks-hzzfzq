/**
 * 全息科技风绘制核心函数 - 荆棘组识别框+抛物线跳跃轨迹
 * @param {Image} img - 底图（游戏画面），传图则绘制，不传新建空白画布
 * @param {Array} data - 荆棘组数据数组，项含startX/startY/endX/endY坐标
 * @param {Object} options - 配置项 {clear:Boolean} 是否清空画布
 * @returns {Image} 绘制完成的图像
 * @compatible Auto.js全版本/安卓Canvas原生/零报错
 * @adaptation 所有像素尺寸已对接sd屏幕适配函数，全机型兼容
 * @update 能量峰文字替换为全息数据面板，面板贴合抛物线顶点，排版更优
 */
function drawImg(img, data, options) {
    // 【初始化区】配置兜底+画布+画笔基础设置
    options = options || {
        clear: false
    };
    let canvas = img ? new Canvas(img) : new Canvas();

    // 【画布操作】仅显式传clear=true时清空，避免无效操作
    if (options.clear === true) {
        canvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);
    }

    // 【数据校验】非数组/空数组直接返回，避免后续报错
    if (!Array.isArray(data) || data.length === 0) {
        let imgMat = canvas.toImage().getMat();
        return images.matToImage(imgMat);
    }

    // 【适配参数区】所有像素尺寸通过sd适配，基准720*1600，全机型兼容
    // 荆棘组框偏移量（基准13/68/58）
    let offsetX13 = sd.x(13, 720);
    let offsetY68 = sd.y(68, 1600);
    let offsetY58 = sd.y(58, 1600);
    // 安全圆角（安卓Canvas[0,16]限制，基准8）
    let safeRoundRadius = sd.x(8, 720);
    // 粒子节点：光晕/实心半径（基准12/5），顶点节点稍大更醒目
    let glowRadius = sd.x(12, 720);
    let pointRadius = sd.x(5, 720);
    let glowRadiusTop = glowRadius + sd.x(3, 720);
    let pointRadiusTop = pointRadius + sd.x(2, 720);
    // 文字：描边宽度/各层级字号（基准1.5/24/26/20）
    let textStrokeWidth = sd.x(1.5, 720);
    let textSizeThorn = sd.x(24, 720); // 荆棘组编号字号
    let textSizeNode = sd.x(26, 720); // 火崽崽/落点标注字号
    let textSizePanel = sd.x(20, 720); // 面板数据字号
    // 全息面板：宽高/偏移（基准180/80），贴合顶点无遮挡，比原面板更精致
    let panelW = sd.x(300, 720);
    let panelH = sd.y(80, 1600);
    let panelXOffset = sd.x(10, 720); // 面板相对顶点X偏移（右移）
    let panelYOffset = sd.y(-100, 1600); // 面板相对顶点Y偏移（下移）
    // 绘制偏移：荆棘组编号/节点文字（基准10/28/15）
    let thornTextX = sd.x(10, 720);
    let thornTextY = sd.y(28, 1600);
    let nodeTextOffset = sd.x(15, 720);
    // 画笔宽度：雷达框/荆棘组主框/能量轨迹/激光轨迹（基准7/2.5/9/3.5）
    let strokeRadar = sd.x(7, 720);
    let strokeThorn = sd.x(2.5, 720);
    let strokeEnergy = sd.x(9, 720);
    let strokeLaser = sd.x(3.5, 720);
    // 抛物线参数：高度系数（基准4.5，拉高轨迹）/分母（基准400）
    let parabolaHeightRatio = 4.5; // 系数越小，抛物线越高
    let parabolaDenominator = 400;
    // 面板文字：行间距（基准20）/内边距（基准15/18），更紧凑精致
    let textYStep = sd.y(20, 1600);
    let textXStart = sd.x(15, 720);
    let textYStart = sd.y(24, 1600);

    // 【荆棘组识别绘制】雷达扫描外层+正红主框+黑边白字编号
    // 雷达扫描框配置：浅红霓虹+粗边+疏密虚线
    paint.setColor(Color.parseColor("#FF6666"));
    paint.setStrokeWidth(strokeRadar);
    let radarDash = new android.graphics.DashPathEffect([sd.x(10, 720), sd.x(3, 720)], 0);
    paint.setPathEffect(radarDash);
    // 荆棘组主框配置：正红霓虹+细边
    let thornMainColor = Color.parseColor("#FF0000");

    // 遍历绘制所有荆棘组
    for (let i = 0; i < data.length; i++) {
        let thorns = data[i];
        let startX = thorns.startX,
            startY = thorns.startY;
        let endX = thorns.endX,
            endY = thorns.endY;
        // 荆棘组框最终坐标
        let left = startX - offsetX13,
            top = startY - offsetY68;
        let right = endX + offsetX13,
            bottom = endY + offsetY58;

        // 1. 绘制雷达扫描外层框（安全圆角）
        canvas.drawRoundRect(left, top, right, bottom, safeRoundRadius, safeRoundRadius, paint);
        paint.setPathEffect(null); // 清除虚线，避免影响后续
        // 2. 绘制荆棘组主轮廓框（安全圆角）
        paint.setColor(thornMainColor);
        paint.setStrokeWidth(strokeThorn);
        canvas.drawRoundRect(left, top, right, bottom, safeRoundRadius, safeRoundRadius, paint);
        // 3. 绘制荆棘组编号：黑边白字+加粗+左对齐（全息数字风格）
        paint.setStyle(Paint.Style.STROKE);
        paint.setColor(Color.parseColor("#000000"));
        paint.setStrokeWidth(textStrokeWidth);
        paint.setTextSize(textSizeThorn);
        paint.setFakeBoldText(true);
        paint.setTextAlign(Paint.Align.LEFT);
        // 编号位置：荆棘组框右上角，不遮挡主体
        canvas.drawText(`[荆棘组${i+1}]`, right + thornTextX, top + thornTextY, paint);
        // 白色填充层，保证所有背景可读
        paint.setStyle(Paint.Style.FILL);
        paint.setColor(Color.parseColor("#FFFFFF"));
        canvas.drawText(`[荆棘组${i+1}]`, right + thornTextX, top + thornTextY, paint);
        // 画笔复位为描边，准备下一个绘制
        paint.setStyle(Paint.Style.STROKE);
    }

    // 【抛物线轨迹绘制】拉高轨迹+能量渐变外层+激光虚线内层
    paint.setStrokeCap(Paint.Cap.ROUND);
    paint.setStyle(Paint.Style.STROKE);
    let firstThorn = data[0];
    // 抛物线基础坐标（对接适配，保留原逻辑）
    let pathStartX = sd.xp(playersWidthPps);
    let pathStartY = firstThorn.startY - sd.y(31, 1600);
    let pathEndX = ckltEndX(data);
    let pathEndY = firstThorn.endY - sd.y(31, 1600);
    let dx = pathEndX - pathStartX;
    let dy = pathEndY - pathStartY;

    // 防错判断：起点终点不重叠+水平距离>10才绘制，过滤无效轨迹
    if (dx !== 0 && Math.abs(dx) > sd.x(10, 720)) {
        // 抛物线核心算法：系数4.5拉高轨迹，适配全机型
        let centerX = pathStartX + dx / 2;
        let topY = pathStartY - Math.max(dx / parabolaHeightRatio, pathEndX / parabolaDenominator);
        let a = (pathEndY - topY) / Math.pow(dx / 2, 2);

        // 生成抛物线路径：逐点连线，保证轨迹顺滑
        let path = new Path();
        path.moveTo(pathStartX, pathStartY);
        for (let x = pathStartX + 1; x <= pathEndX; x++) {
            let offsetX = x - centerX;
            let y = a * Math.pow(offsetX, 2) + topY;
            path.lineTo(x, y);
        }

        // 1. 能量渐变外层轨迹：青蓝→深蓝，模拟能量波流动
        // let energyGradient = new android.graphics.LinearGradient(
        //     pathStartX, pathStartY, centerX, topY,
        //     Color.parseColor("#66CCFF"), Color.parseColor("#0000FF"),
        //     android.graphics.Shader.TileMode.CLAMP
        // );
        // paint.setShader(energyGradient);
        paint.setStrokeWidth(strokeEnergy);
        paint.setPathEffect(null);
        canvas.drawPath(path, paint);
        paint.setShader(null); // 清除着色器，避免串色

        // 2. 激光密虚线内层轨迹：亮蓝+密虚线，模拟瞄准线
        paint.setColor(Color.parseColor("#0099FF"));
        paint.setStrokeWidth(strokeLaser);
        let laserDash = new android.graphics.DashPathEffect([sd.x(5, 720), sd.x(2, 720)], 0);
        paint.setPathEffect(laserDash);
        canvas.drawPath(path, paint);
        paint.setPathEffect(null); // 清除虚线，准备绘制节点

        // 【粒子节点绘制】双层光晕+配色区分，顶点节点放大更醒目
        paint.setStyle(Paint.Style.FILL);
        // 火崽崽（起点）：青绿色双层光晕+实心点
        paint.setColor(Color.parseColor("#3300FF99"));
        canvas.drawCircle(pathStartX, pathStartY, glowRadius, paint);
        paint.setColor(Color.parseColor("#6600FF66"));
        canvas.drawCircle(pathStartX, pathStartY, glowRadius - sd.x(3, 720), paint);
        paint.setColor(Color.parseColor("#00FF99"));
        canvas.drawCircle(pathStartX, pathStartY, pointRadius, paint);
        // 能量顶点（核心）：紫蓝色双层光晕+放大实心点，视觉焦点
        paint.setColor(Color.parseColor("#339900FF"));
        canvas.drawCircle(centerX, topY, glowRadiusTop, paint);
        paint.setColor(Color.parseColor("#669900FF"));
        canvas.drawCircle(centerX, topY, glowRadiusTop - sd.x(3, 720), paint);
        paint.setColor(Color.parseColor("#9900FF"));
        canvas.drawCircle(centerX, topY, pointRadiusTop, paint);
        // 落点（终点）：橙红色双层光晕+实心点
        paint.setColor(Color.parseColor("#33FF3300"));
        canvas.drawCircle(pathEndX, pathEndY, glowRadius, paint);
        paint.setColor(Color.parseColor("#66FF0066"));
        canvas.drawCircle(pathEndX, pathEndY, glowRadius - sd.x(3, 720), paint);
        paint.setColor(Color.parseColor("#FF6600"));
        canvas.drawCircle(pathEndX, pathEndY, pointRadius, paint);

        // 【节点文字标注】仅保留火崽崽/落点，能量峰替换为面板，排版更优
        paint.setStyle(Paint.Style.STROKE);
        paint.setColor(Color.parseColor("#000000"));
        paint.setStrokeWidth(textStrokeWidth);
        paint.setTextSize(textSizeNode);
        paint.setFakeBoldText(true);
        paint.setTextAlign(Paint.Align.LEFT);
        // 火崽崽文字：左上方偏移，避开面板和节点
        canvas.drawText(`[火崽崽]`, pathStartX - nodeTextOffset * 3, pathStartY - nodeTextOffset, paint);
        paint.setStyle(Paint.Style.FILL);
        paint.setColor(Color.parseColor("#00FF99"));
        canvas.drawText(`[火崽崽]`, pathStartX - nodeTextOffset * 3, pathStartY - nodeTextOffset, paint);
        // 落点文字：右上方偏移，无遮挡
        paint.setStyle(Paint.Style.STROKE);
        paint.setColor(Color.parseColor("#000000"));
        canvas.drawText(`[落点]`, pathEndX + nodeTextOffset, pathEndY - nodeTextOffset, paint);
        paint.setStyle(Paint.Style.FILL);
        paint.setColor(Color.parseColor("#FF6600"));
        canvas.drawText(`[落点]`, pathEndX + nodeTextOffset, pathEndY - nodeTextOffset, paint);
        // 【全息数据面板】替换原能量峰文字，贴合顶点右侧，精致紧凑无遮挡
        let panelPaint = new Paint();
        panelPaint.setAntiAlias(true);
        panelPaint.setStyle(Paint.Style.FILL);
        panelPaint.setColor(Color.parseColor("#99000000")); // 半透黑全息质感，稍加深更醒目
        // 面板坐标：贴合抛物线顶点右侧+微下移，原能量峰位置，无任何遮挡
        let panelLeft = centerX + panelXOffset;
        let panelTop = topY + panelYOffset;
        let panelRight = panelLeft + panelW;
        let panelBottom = panelTop + panelH;
        // 绘制面板底框：大圆角更精致（基准10），贴合科技风
        let panelRound = sd.x(10, 720);
        canvas.drawRoundRect(panelLeft, panelTop, panelRight, panelBottom, panelRound, panelRound, panelPaint);

        // 面板多维度实战数据计算，保留核心实用数据
        let jumpDist = Math.abs(dx).toFixed(0); // 水平跳跃距离
        let pressTime = ckltJumpToXTime(pathEndX).toFixed(1); // 核心长按时长
        let jumpSpeed = (jumpDist / pressTime * 1000).toFixed(1); // 跳跃速度(px/s)
        let vertexHeight = Math.abs(pathStartY - topY).toFixed(0); // 顶点高度
        let thornCount = data.length; // 荆棘组总数

        // 绘制面板文字：黑边+科技浅蓝填充，分行紧凑，适配面板尺寸
        paint.setStyle(Paint.Style.STROKE);
        paint.setColor(Color.parseColor("#000000"));
        paint.setStrokeWidth(textStrokeWidth);
        paint.setTextSize(textSizePanel);
        paint.setFakeBoldText(true);
        paint.setTextAlign(Paint.Align.LEFT);
        // 面板文字起始坐标：内边距，不贴边更精致
        let panelTextX = panelLeft + textXStart;
        let panelTextY = panelTop + textYStart;
        // 第一行：核心操作参数（长按时长+水平距离）
        canvas.drawText(`长按：${pressTime}ms | 距离：${jumpDist}px`, panelTextX, panelTextY, paint);
        paint.setStyle(Paint.Style.FILL);
        paint.setColor(Color.parseColor("#80E5FF")); // 科技浅蓝，比原蓝更通透
        canvas.drawText(`长按：${pressTime}ms | 距离：${jumpDist}px`, panelTextX, panelTextY, paint);
        // 第二行：跳跃性能（速度+顶点高度）
        paint.setStyle(Paint.Style.STROKE);
        paint.setColor(Color.parseColor("#000000"));
        canvas.drawText(`速度：${jumpSpeed}px/s | 高度：${vertexHeight}px`, panelTextX, panelTextY + textYStep, paint);
        paint.setStyle(Paint.Style.FILL);
        paint.setColor(Color.parseColor("#80E5FF"));
        canvas.drawText(`速度：${jumpSpeed}px/s | 高度：${vertexHeight}px`, panelTextX, panelTextY + textYStep, paint);
        // 第三行：场景信息（荆棘组总数）
        paint.setStyle(Paint.Style.STROKE);
        paint.setColor(Color.parseColor("#000000"));
        canvas.drawText(`当前荆棘组：${thornCount}个`, panelTextX, panelTextY + textYStep * 2, paint);
        paint.setStyle(Paint.Style.FILL);
        paint.setColor(Color.parseColor("#80E5FF"));
        canvas.drawText(`当前荆棘组：${thornCount}个`, panelTextX, panelTextY + textYStep * 2, paint);

        // 画笔最终复位：避免外部调用受当前样式影响
        paint.setStyle(Paint.Style.STROKE);
        paint.setStrokeWidth(sd.x(1, 720));
        paint.setColor(Color.parseColor("#000000"));
    }

    // 【最终返回】画布转Mat再转Image，保留原兼容逻辑
    let imgMat = canvas.toImage().getMat();
    return images.matToImage(imgMat);
}
